// DOM-Model mapping rules:
// * A DOM node must be associated to a unique model node and vice-versa.
// * A DOM node must be of the type prescribed by the model node.

/**
 * Handles the rendering and editing of a sequence of nodes.
 * Instantiated by a surface registry.
 * Possible actions: InsertNode, RemoveNode
 *
 * @class
 * @param {*} id - The ID generated by the surface registry.
 * @paramÂ {Node[]} nodes - The node list to edit.
 * @param {HTMLElement} dom - The DOM node which will contain the editor's
 * editing surface.
 * @param {Writer.Editor} editor - The parent editor instance.
 */
Writer.Surface = class Surface {
  constructor(id, nodes, dom, editor) {
    /**
     * ID provided by the surface registry.
     *
     * @private
     * @type {*}
     */
    this.id = id;

    /**
     * A parent surface if there is one. If for a given surface, this attribute
     * is set to `null`, this surface is the mother surface.
     * See the read-me for more informations on the Surface hierarchy.
     *
     * @private
     * @todo FIX!!!
     * @type {Writer.Surface}
     */
    this.parent = null;

    /**
     * The editor to which the surface belongs.
     *
     * @type {Writer.Editor}
     */
    this.editor = editor;

    /**
     * The editable node.
     *
     * @private
     * @type {HTMLElement}
     */
    this.dom = dom;

    /**
     * The `History` instance that will be used to pipeline and execute edits.
     *
     * @type {Writer.History}
     */
    this.history = editor.history;

    /**
     * The editor's accumulator instance.
     *
     * @type {Writer.Accumulator}
     */
    this.accumulator = editor.accumulator;

    /**
     * The surface's selection handler.
     *
     * @type {Writer.SurfaceSelection}
     */
    this.selection = new Writer.SurfaceSelection(this);

    /**
     * If set to true, critical inputs will be handled.
     *
     * @private
     * @type {Boolean}
     */
    this.handleCriticalInputs = false;

    /**
     * The array of nodes rendered and updated by the surface.
     * It is usually a reference to a document's node list.
     *
     * @private
     * @type {Node[]}
     */
    this.nodes = nodes;

    /**
     * Behavior for handling of critical inputs.
     */
    this.behavior = Writer.DefaultBehavior;

    // Set the ID as a data attribute
    this.dom.dataset[Writer.prefix + "SurfaceId"] = this.id;

    // Add all the document's node to the DOM
    for(var i = 0; i < nodes.length; i++) {
      nodes[i].attach(this);
      this.dom.appendChild(nodes[i].dom);
    }

    this.updatePositions();
  }

  /**
   * Returns true if a given DOM node is inside the surface or is the surface
   * itself.
   *
   * @param {Element} node - A DOM node.
   * @returns {Boolean}
   */
  contains(node) {
    return this.dom === node || this.dom.contains(node);
  }

  /**
   * Internal function that calls the proper handler for an event, whether its
   * default or its overriden implementation.
   *
   * @private
   * @param {String} name - The name of the event.
   * @param {Event} event - The DOM event object.
   * @returns {Boolean} True if a handler was found.
   */
  handle(name, event) {
    var cmd; // Will store the returned command.

    // Separate the handling of events according to the state of selection.
    if(!this.selection.caret)
      name = "Selection+" + name;

    // If the selection is restrained to a single node, directly use the node's
    // handler.
    if(this.selection.inSameNode &&
       this.selection.startNode.behavior.hasOwnProperty(name)) {
      cmd = this.selection.startNode.behavior[name].call(this, event);
    }

    // Else, use the surface's handler.
    else if(this.behavior.hasOwnProperty(name)) {
      cmd = this.behavior[name].call(this, event);
    }

    else {
      return false;
    }

    // Add to history so that the operation is cancelable
    if(cmd)
      this.history.push(cmd);
    return true;
  }

  /**
   * Inserts a node in the surface. Should not be called directly but only
   * through the `InsertNode` command.
   *
   * @private
   * @param {Writer.Node} node - The node to insert.
   * @param {Number} pos - The position at which it will be inserted.
   */
  insertNode(node, pos) {
    // assert(pos > 0)
    // assert(pos <= this.nodes.length)

    node.attach(this);

    // Insert in the DOM
    if(pos === this.nodes.length) // Insert after the current last node
      this.dom.appendChild(node.dom);
    else // Insert before another node
      this.dom.insertBefore(node.dom, this.nodes[pos].dom);

    this.nodes.splice(pos, 0, node); // Insert into array.
    this.updatePositions();
  }

  /**
   * Removes a node from the surface. Should not be called directly but only
   * through the `RemoveNode` command.
   *
   * @private
   * @param {Number} id - The node's ID.
   */
  removeNode(id) {
    // assert(pos > 0)
    // assert(pos < this.nodes.length)

    var node = this.nodes.splice(id, 1)[0];
    this.dom.removeChild(node.dom);
    node.detach();
    this.updatePositions();
  }

  /**
   * Notifies the nodes of their new position.
   *
   * @private
   */
  updatePositions() {
    for(var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].setPosition(i);
    }
  }
};
